import {
  PaymentMethod,
  PaymentStatus,
} from '@/interfaces/payment';
import { SystemSettingsService } from './system-settings-service';
import { MonnifyService } from './monnify-service';
import { PaystackService } from './paystack-service';

interface PaymentInitializeResponse {
  checkoutUrl: string;
  reference: string;
  provider: 'monnify' | 'paystack';
  accessCode?: string; // Paystack specific
}

/**
 * PaymentService Facade
 * Routes requests to the active payment provider (Monnify or Paystack)
 */
export class PaymentService {
  
  /**
   * Initialize a payment transaction
   */
  static async initializePayment(
    params: {
      amount: number;
      customerName: string;
      customerEmail: string;
      paymentReference: string;
      paymentDescription: string;
      currencyCode?: string;
      contractCode?: string; // Legacy Monnify param
      redirectUrl: string;
      paymentMethods?: PaymentMethod[];
    }
  ): Promise<PaymentInitializeResponse> {
    const settings = await SystemSettingsService.getPaymentSettings();

    if (settings.activeProvider === 'paystack') {
      try {
        // Convert amount to kobo for Paystack (NGN * 100)
        // Check if amount is already in kobo? No, typically amount is passed as NGN in app logic?
        // Monnify expects NGN amount (e.g. 100.00). Paystack expects kobo (10000).
        // Let's assume input `amount` is NGN (base currency).
        
        const paystackResponse = await PaystackService.initializeTransaction({
          email: params.customerEmail,
          amount: Math.round(params.amount * 100),
          reference: params.paymentReference,
          callback_url: params.redirectUrl,
          metadata: {
            custom_fields: [
              {
                display_name: "Customer Name",
                variable_name: "customer_name",
                value: params.customerName
              }
            ]
          }
        });

        return {
          checkoutUrl: paystackResponse.data.authorization_url,
          reference: paystackResponse.data.reference,
          provider: 'paystack',
          accessCode: paystackResponse.data.access_code
        };
      } catch (error) {
        console.error('Paystack initialization failed:', error);
        throw error;
      }
    } else {
      // Default to Monnify
      try {
        const monnifyResponse = await MonnifyService.initializePayment({
          amount: params.amount,
          customerName: params.customerName,
          customerEmail: params.customerEmail,
          paymentReference: params.paymentReference,
          paymentDescription: params.paymentDescription,
          currencyCode: params.currencyCode || 'NGN',
          redirectUrl: params.redirectUrl,
          paymentMethods: params.paymentMethods || ['CARD', 'ACCOUNT_TRANSFER']
        });

        return {
          checkoutUrl: monnifyResponse.responseBody.checkoutUrl,
          reference: monnifyResponse.responseBody.paymentReference,
          provider: 'monnify'
        };
      } catch (error) {
        console.error('Monnify initialization failed:', error);
        throw error;
      }
    }
  }

  /**
   * Verify payment status
   */
  static async verifyPayment(paymentReference: string): Promise<{
    status: PaymentStatus;
    amount: number;
    paidAt?: Date;
    transactionReference?: string;
    provider: 'monnify' | 'paystack';
  }> {
    // We need to know which provider to verify with. 
    // We can try determining from reference format or check active provider.
    // Monnify refs start with 'WAWA-'. Paystack refs also use 'WAWA-' if generated by us.
    // However, we stored the paymentReference in the order.
    // A robust way is to try verifying with the active provider, or fallback.
    // Or encode provider in reference? e.g. WAWA-M-... vs WAWA-P-...
    // For now, let's check active settings. If reference formats are identical, we might need a try-catch approach.
    
    const settings = await SystemSettingsService.getPaymentSettings();
    
    // Strategy: Try the active provider first. If it fails (404), try the other?
    // Monnify verification throws if failed.
    
    if (settings.activeProvider === 'paystack') {
        try {
            const response = await PaystackService.verifyTransaction(paymentReference);
            
            let status: PaymentStatus = 'PENDING';
            if (response.data.status === 'success') status = 'PAID';
            else if (response.data.status === 'failed') status = 'FAILED';
            else if (response.data.status === 'abandoned') status = 'CANCELLED';
            
            return {
                status,
                amount: response.data.amount / 100, // Convert kobo to NGN
                paidAt: response.data.paid_at ? new Date(response.data.paid_at) : undefined,
                transactionReference: response.data.id.toString(),
                provider: 'paystack'
            };
        } catch (error: any) {
             // If verification fails (e.g. transaction not found), we could fallback to Monnify if needed,
             // but usually we stick to the one configured.
             // However, for existing pending transactions initiated with the OLD provider before switch,
             // we might need to handle that. 
             // For simplicity now, we rely on active provider.
             throw error;
        }
    } else {
        const response = await MonnifyService.verifyPayment(paymentReference);
        return {
            status: response.responseBody.paymentStatus,
            amount: response.responseBody.amountPaid,
            paidAt: response.responseBody.paidOn ? new Date(response.responseBody.paidOn) : undefined,
            transactionReference: response.responseBody.transactionReference,
            provider: 'monnify'
        };
    }
  }

  /**
   * Generate payment reference
   */
  static generatePaymentReference(orderId: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8).toUpperCase();
    // Optional: Prefix based on provider could help routing verification later
    return `WAWA-${orderId}-${timestamp}-${random}`;
  }

  /**
   * Check if payment is successful
   */
  static isPaymentSuccessful(status: PaymentStatus): boolean {
    return status === 'PAID' || status === 'OVERPAID';
  }

  /**
   * Get payment method display name
   */
  static getPaymentMethodName(method: PaymentMethod): string {
    return MonnifyService.getPaymentMethodName(method);
  }

  /**
   * Get payment method instructions
   */
  static getPaymentMethodInstructions(method: PaymentMethod): string {
    return MonnifyService.getPaymentMethodInstructions(method);
  }

  /**
   * Format amount for display
   */
  static formatAmount(amount: number): string {
    return MonnifyService.formatAmount(amount);
  }

  /**
   * Calculate payment fees (if applicable)
   */
  static calculatePaymentFee(amount: number, method: PaymentMethod): number {
    return MonnifyService.calculatePaymentFee(amount, method);
  }
}
